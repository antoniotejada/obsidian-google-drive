/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GoogleDrive
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var debugLevels = ["debug", "info", "warn", "error"];
var logError = function(message, ...optionalParams) {
};
var logWarn = function(message, ...optionalParams) {
};
var logInfo = function(message, ...optionalParams) {
};
var logDbg = function(message, ...optionalParams) {
};
function hookLogFunctions(debugLevelIndex, tag) {
  logInfo("hookLogFunctions", debugLevelIndex, tag);
  const logIgnore = function(message, ...optionalParams) {
  };
  logError = debugLevelIndex <= debugLevels.indexOf("error") ? console.error.bind(console, tag + "[ERROR]:") : logIgnore;
  logWarn = debugLevelIndex <= debugLevels.indexOf("warn") ? console.warn.bind(console, tag + "[WARN]:") : logIgnore;
  logInfo = debugLevelIndex <= debugLevels.indexOf("info") ? console.info.bind(console, tag + "[INFO]:") : logIgnore;
  logDbg = debugLevelIndex <= debugLevels.indexOf("debug") ? console.debug.bind(console, tag + "[DEBUG]:") : logIgnore;
}
hookLogFunctions(debugLevels.indexOf("debug"), "GoogleDrive");
var DEFAULT_SETTINGS = {
  debugLevel: "debug",
  accessToken: "",
  accessExpires: "",
  refreshToken: "",
  // Empty to disable, positive nonzero to enable
  // XXX Periodic synchronization not implemented yet
  // XXX In the future 0 may mean watch changes (in theory allowed with
  //     drive.file scope?)
  syncIntervalSecs: "",
  syncMode: "both",
  syncStartTime: "0",
  folderId: "root",
  parentIds: "",
  browseOrphans: false,
  // obsidiangdrive clientId (web app)
  clientId: "800679030178-3pd3ct4pic1tkfn9l366a6uhak38gqio.apps.googleusercontent.com",
  clientSecret: "",
  clientScope: "https://www.googleapis.com/auth/drive.file",
  redirectUri: "http://localhost",
  // XXX Not implemented yet
  encryptFilenames: false,
  // XXX Not implemented yet
  encryptionPassword: "",
  // XXX Not implemented yet
  compressFiles: false
};
var GoogleDrive = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.maxLoginRetries = 3;
    this.downloadChanges = true;
    this.uploadChanges = true;
    this.loginPromise = null;
    this.refreshPromise = null;
    // 0 no sync, positive nonzero sync, negative filtered out beforehand.
    // Initialized to zero to force toggle if enabled in the configuration
    this.syncIntervalSecs = 0;
    this.syncIntervalId = null;
  }
  async onload() {
    logInfo("onload");
    await this.loadSettings();
    this.addRibbonIcon("sync", "Synchronize vault with Google Drive", (evt) => {
      this.syncVault();
    });
    this.addCommand({
      id: "open-login-modal",
      name: "Open login modal",
      callback: async () => {
        await new Promise((resolve, reject) => {
          new LoginModal(this, false, resolve, reject).open();
        });
      }
    });
    this.addCommand({
      id: "show-debug-information",
      name: "Show debug information",
      callback: () => {
        const fragment = createFragment((fragment2) => {
          fragment2.createDiv({ text: this.settings.clientId != DEFAULT_SETTINGS.clientId ? "Non-default ClientId" : "Default ClientId" });
          fragment2.createDiv({ text: this.settings.clientSecret != DEFAULT_SETTINGS.clientSecret ? "Non-default ClientSecret" : "Default ClientSecret" });
          fragment2.createDiv({ text: this.settings.clientScope != DEFAULT_SETTINGS.clientScope ? "Non-default ClientScope" : "Default ClientScope" });
          fragment2.createDiv({ text: JSON.stringify(this.settings, void 0, 4) });
        });
        const notice = new import_obsidian.Notice(fragment, 0);
        const noticeContainer = notice.noticeEl.parentElement;
        noticeContainer.style.maxHeight = "100%";
        noticeContainer.style.overflow = "scroll";
      }
    });
    this.addCommand({
      id: "synchronize-vault",
      name: "Synchronize Vault",
      checkCallback: (checking) => {
        if (this.settings.accessToken != "" && this.settings.folderId != "") {
          if (!checking) {
            this.syncVault();
          }
          return true;
        }
      }
    });
    this.addSettingTab(new GoogleDriveSettingsTab(this.app, this));
  }
  onunload() {
    logInfo("onunload");
  }
  parseSettings(settings) {
    hookLogFunctions(debugLevels.indexOf(settings.debugLevel), "GoogleDrive");
    this.uploadChanges = settings.syncMode == "both" || settings.syncMode == "upload";
    this.downloadChanges = settings.syncMode == "both" || settings.syncMode == "download";
    let syncIntervalSecs = parseInt(settings.syncIntervalSecs);
    syncIntervalSecs = isNaN(syncIntervalSecs) ? 0 : Math.max(0, syncIntervalSecs);
    if (this.syncIntervalSecs != syncIntervalSecs) {
      if (this.syncIntervalId != null) {
        logInfo("Clearing syncInterval id", this.syncIntervalId);
        window.clearInterval(this.syncIntervalId);
        this.syncIntervalId = null;
      }
      this.syncIntervalSecs = syncIntervalSecs;
      if (this.syncIntervalSecs != 0) {
        this.syncIntervalId = window.setInterval(() => {
          logWarn("Periodic synchronization not implemented yet");
        }, this.syncIntervalSecs * 1e3);
        logInfo(
          "Setting syncInterval id",
          this.syncIntervalId,
          "secs",
          this.syncIntervalSecs
        );
        this.registerInterval(this.syncIntervalId);
      }
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.parseSettings(this.settings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.parseSettings(this.settings);
  }
  async fetchApi(endpoint, params = null, init = null) {
    let loginRetries = 0;
    let resp;
    while (true) {
      init = Object.assign({ method: "GET" }, init);
      init.headers = Object.assign(init.headers || {}, { "Authorization": "Bearer " + this.settings.accessToken });
      const query = params == null ? "" : "?" + new URLSearchParams(params).toString();
      logInfo("fetchApi doing fetch", init, query);
      resp = await fetch(
        "https://www.googleapis.com/" + endpoint + query,
        init
      );
      if (!resp.ok && resp.status != 404) {
        logWarn("fetchApi failed", resp.status, resp.statusText);
        if (resp.headers.get("content-type") == "application/json; charset=UTF-8") {
          logWarn("fetchApi error json", await resp.json());
        }
        loginRetries++;
        if (loginRetries > this.maxLoginRetries) {
          logError("Maximum login retries", this.maxLoginRetries, "exceeded");
          break;
        }
        if (this.settings.refreshToken != "") {
          logInfo("Refreshing token");
          const tokenParams = new URLSearchParams({
            client_id: this.settings.clientId,
            client_secret: this.settings.clientSecret,
            grant_type: "refresh_token",
            refresh_token: this.settings.refreshToken
          });
          let p = this.refreshPromise;
          if (p == null) {
            logInfo("Creating refreshPromise");
            p = new Promise((resolve, reject) => {
              let p2 = fetch("https://oauth2.googleapis.com/token", {
                method: "POST",
                headers: {
                  "Content-Type": "application/x-www-form-urlencoded"
                },
                body: tokenParams
              }).then(async (resp2) => {
                if (resp2.ok) {
                  let jsonResp = await resp2.json();
                  logInfo("refresh token succeeded", resp2, jsonResp);
                  this.settings.accessToken = jsonResp.access_token;
                  this.settings.accessExpires = (0, import_obsidian.moment)().add(jsonResp.expires_in, "second").format();
                } else {
                  logError("refresh token failed", resp2, resp2.status, resp2.statusText);
                  if (resp2.headers.get("content-type") == "application/json; charset=UTF-8") {
                    logWarn("fetchApi error json", await resp2.json());
                  }
                  this.settings.accessToken = "";
                  this.settings.refreshToken = "";
                }
                await this.saveSettings();
                resolve(resp2);
              });
            });
            this.refreshPromise = p;
          } else {
            logInfo("Reusing refreshPromise");
          }
          resp = await p;
          if (this.refreshPromise != null) {
            this.refreshPromise = null;
          }
        }
        if (!resp.ok) {
          logInfo("fetchApi prompting for login");
          let p = this.loginPromise;
          if (p == null) {
            logInfo("Creating loginPromise");
            p = new Promise((resolve, reject) => {
              let login = new LoginModal(this, true, resolve, reject);
              login.open();
            });
            this.loginPromise = p;
          } else {
            logInfo("Reusing loginPromise");
          }
          let ok = await p;
          if (this.loginPromise != null) {
            this.loginPromise = null;
          }
          if (!ok) {
            break;
          }
        }
      } else {
        break;
      }
    }
    return resp;
  }
  async fetchJson(endpoint, params = null, init = null) {
    return this.fetchApi(endpoint, params, init).then((resp) => {
      return resp.json();
    });
  }
  async fetchFiles(folderId, files = [], pageToken = "") {
    logInfo("fetchFiles", folderId, pageToken);
    const params = {
      q: "('" + folderId + "' in parents) and (not trashed)",
      fields: "nextPageToken, files(id, name, mimeType, modifiedTime, createdTime)",
      pageToken
    };
    return this.fetchJson("drive/v3/files", params).then((resp) => {
      logInfo(resp);
      resp.files.forEach((f) => {
        files.push(f);
      });
      if (resp.nextPageToken !== void 0) {
        return this.fetchFiles(folderId, files, resp.nextPageToken);
      } else {
        return files;
      }
    });
  }
  async fetchCreateFolder(parentId, folderName) {
    logInfo("fetchCreateFolder", parentId, folderName);
    const metadata = { name: folderName, mimeType: "application/vnd.google-apps.folder", parents: [parentId] };
    const init = {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(metadata)
    };
    return this.fetchJson("drive/v3/files", null, init);
  }
  async fetchFolderPath(folderId) {
    logInfo("fetchFolderPath", folderId);
    const params = { fields: "name,parents" };
    return this.fetchJson("drive/v3/files/" + folderId, params).then((resp) => {
      var _a;
      logInfo("fetchFolderPath", resp);
      if (((_a = resp == null ? void 0 : resp.error) == null ? void 0 : _a.code) == 404) {
        return "/";
      }
      if (resp.parents !== void 0 && resp.parents.length > 0) {
        return this.fetchFolderPath(resp.parents[0]).then((path) => {
          return path + resp.name + "/";
        });
      } else {
        return resp.name + "/";
      }
    });
  }
  async syncVault() {
    logInfo("syncVault");
    if (this.settings.accessToken != "" && this.settings.folderId != "") {
      const syncStartTime = Date.now();
      this.syncFolder(this.settings.folderId, this.app.vault.getRoot()).then(async () => {
        this.settings.syncStartTime = syncStartTime.toString();
        await this.saveSettings();
      });
    }
  }
  async syncFolder(folderId, vaultFolder) {
    logInfo("syncFolder", folderId, vaultFolder.path);
    const notice = new import_obsidian.Notice("Synchronizing " + vaultFolder.path);
    let vaultFiles = vaultFolder.children.slice();
    const vault = vaultFolder.vault;
    vaultFiles.sort((a, b) => a.name.localeCompare(b.name));
    logInfo("vaultFiles", vaultFiles);
    let driveFiles = await this.fetchFiles(folderId);
    driveFiles.sort((a, b) => a.name.localeCompare(b.name));
    logInfo("driveFiles", driveFiles);
    let id = 0;
    let iv = 0;
    const fileNotice = new import_obsidian.Notice("Synchronizing " + vaultFolder.path);
    while (id < driveFiles.length || iv < vaultFiles.length) {
      const vaultFile = iv < vaultFiles.length ? vaultFiles[iv] : null;
      const driveFile = id < driveFiles.length ? driveFiles[id] : null;
      logInfo("Comparing vault", iv, vaultFile == null ? void 0 : vaultFile.name, "to drive", id, driveFile == null ? void 0 : driveFile.name);
      const vaultIsFolder = vaultFile instanceof import_obsidian.TFolder;
      const driveIsFolder = (driveFile == null ? void 0 : driveFile.mimeType) == "application/vnd.google-apps.folder";
      let update = false;
      let cmp;
      if (vaultFile == null) {
        cmp = 1;
      } else if (driveFile == null) {
        cmp = -1;
      } else {
        cmp = vaultFile.name.localeCompare(driveFile.name);
      }
      if (cmp == 0) {
        const vfile = vaultFile;
        const dfile = driveFile;
        fileNotice.setMessage(vfile.name);
        if (vaultIsFolder != driveIsFolder) {
          logError("Folder vs. file mismatch for", vfile.name, dfile.name);
        } else if (vaultIsFolder) {
          logInfo("Recursing folder", dfile.name, vfile.name);
          await this.syncFolder(dfile.id, vaultFile);
        } else {
          const gtime = Date.parse(dfile.modifiedTime);
          const vtime = vfile.stat.mtime;
          const dcmp = gtime - vtime;
          if (dcmp < -1) {
            logInfo("Will copy from vault", dcmp, vfile.name, "to drive", dfile.name, gtime, new Date(gtime), "<", vtime, new Date(vtime));
            cmp = -1;
            update = true;
          } else if (dcmp > 1) {
            logInfo("Will copy from drive", dcmp, dfile.name, "to vault", vfile.name, gtime, new Date(gtime), ">", vtime, new Date(vtime));
            cmp = 1;
            update = true;
          } else {
            logInfo("Ignoring same time", dcmp, gtime, new Date(gtime), "vs", vtime, new Date(vtime), "drive", dfile.name, "as vault", vfile.name);
          }
        }
        if (cmp != -1) {
          iv++;
        }
        if (cmp != 1) {
          id++;
        }
      }
      if (cmp == -1) {
        fileNotice.setMessage(vaultFile == null ? void 0 : vaultFile.name);
        if (this.uploadChanges) {
          if (vaultIsFolder) {
            logInfo("Creating drive folder", vaultFile.name);
            const resp = await this.fetchCreateFolder(folderId, vaultFile.name);
            let subFolderId = resp.id;
            logInfo("Recursing folder", vaultFile.name, vaultFile.name);
            await this.syncFolder(subFolderId, vaultFile);
          } else {
            const vfile = vaultFile;
            logInfo("Uploading to drive", vfile.name, "from vault", vfile.name);
            const buffer = await vault.readBinary(vfile);
            const mimeType = "application/octet-stream";
            const metadata = {
              name: vfile.name,
              modifiedTime: new Date(vfile.stat.mtime).toISOString(),
              createdTime: new Date(vfile.stat.ctime).toISOString(),
              mimeType,
              parents: [folderId]
            };
            const updateMetadata = {
              // Note google drive will fail with 403 if
              // createdTime is updated, it can only be set at
              // creation time
              modifiedTime: new Date(vfile.stat.mtime).toISOString()
            };
            const form = new FormData();
            form.append("metadata", new Blob([JSON.stringify(update ? updateMetadata : metadata)], { type: "application/json; charset=UTF-8" }));
            form.append("file", new Blob([buffer], { type: mimeType }));
            const params = { uploadType: "multipart" };
            const query = update ? "/" + (driveFile == null ? void 0 : driveFile.id) : "";
            const init = {
              method: update ? "PATCH" : "POST",
              body: form
            };
            let resp = await this.fetchJson("upload/drive/v3/files" + query, params, init);
            logInfo(resp);
          }
        }
        iv++;
      } else if (cmp == 1) {
        fileNotice.setMessage(driveFile == null ? void 0 : driveFile.name);
        if (this.downloadChanges) {
          const dfile = driveFile;
          let vaultFilepath = dfile.name;
          if (vaultFolder.path != "/") {
            vaultFilepath = vaultFolder.path + "/" + vaultFilepath;
          }
          if (driveIsFolder) {
            logInfo("Creating vault folder", vaultFilepath);
            await vault.createFolder(vaultFilepath).catch((error) => null);
            let vaultSubFolder = vault.getAbstractFileByPath(vaultFilepath);
            if (vaultSubFolder instanceof import_obsidian.TFolder) {
              logInfo("Recursing folder", dfile.name, dfile.name);
              await this.syncFolder(dfile.id, vaultSubFolder);
            } else {
              logError("Can't create folder", vaultFilepath, ", ignoring", dfile.name);
            }
          } else {
            logInfo("Downloading from drive", dfile.name, "to vault", dfile.name);
            const resp = await this.fetchApi("drive/v3/files/" + dfile.id, { alt: "media" });
            const buffer = await resp.arrayBuffer();
            try {
              if (update) {
                await vault.modifyBinary(vaultFile, buffer, { mtime: Date.parse(dfile.modifiedTime), ctime: Date.parse(dfile.createdTime) });
              } else {
                await vault.createBinary(vaultFilepath, buffer, { mtime: Date.parse(dfile.modifiedTime), ctime: Date.parse(dfile.createdTime) });
              }
              logInfo("Copied", buffer.byteLength, "bytes");
            } catch (e) {
              logError("Error createBinary", e);
            }
          }
        }
        id++;
      }
    }
    notice.setMessage("Synchronized " + vaultFolder.path);
  }
};
var TextInputModal = class extends import_obsidian.Modal {
  constructor(app, title, prompt, onSubmit) {
    super(app);
    this.title = title;
    this.prompt = prompt;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    this.titleEl.setText(this.title);
    new import_obsidian.Setting(contentEl).setName(this.prompt).addText((text) => text.onChange((value) => {
      this.result = value;
    }));
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Ok").setCta().onClick(() => {
      this.close();
      this.onSubmit(this.result);
    })).addButton((btn) => btn.setButtonText("Cancel").onClick(() => {
      this.close();
    }));
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};
var LoginModal = class extends import_obsidian.Modal {
  constructor(plugin, showOkCancel, resolve, reject) {
    super(plugin.app);
    this.showGoogleCloudConfiguration = false;
    this.plugin = plugin;
    this.resolve = resolve;
    this.reject = reject;
    this.showOkCancel = showOkCancel;
  }
  buildAuthParams() {
    let authParams;
    if (this.plugin.settings.clientSecret == "") {
      authParams = {
        client_id: this.plugin.settings.clientId,
        // The google auth2 form doesn't allow internal urls like
        // obsidian://gdriveresponse and Using fetch causes CORS error
        // 'app://obsidian.md' has been blocked by CORS policy: No
        // 'Access-Control-Allow-Origin' header is present on the
        // requested resource.
        redirect_uri: this.plugin.settings.redirectUri,
        // XXX This returns the access token directly, should probably use
        //     'code' so it can be converted to an access token and refresh
        //     token?
        // XXX 'code' requires client secret, but token does not
        response_type: "token",
        // Note the scope is valid for the duration of this token and
        // any refreshed token, so limiting the scope after the fact
        // doesn't do anything
        scope: this.plugin.settings.clientScope
        // XXX drive.file scope only allows working with files created
        //     by this app, investigate?
        //scope: 'https://www.googleapis.com/auth/drive',
      };
    } else {
      authParams = {
        client_id: this.plugin.settings.clientId,
        // The google auth2 form doesn't allow internal urls like
        // obsidian://gdriveresponse and Using fetch causes CORS error
        // 'app://obsidian.md' has been blocked by CORS policy: No
        // 'Access-Control-Allow-Origin' header is present on the
        // requested resource.
        redirect_uri: this.plugin.settings.redirectUri,
        // XXX This returns the access token directly, should probably use
        //     'code' so it can be converted to an access token and refresh
        //     token?
        // XXX 'code' requires client secret, but token does not
        response_type: "code",
        // Note the scope is valid for the duration of this token and
        // any refreshed token, so limiting the scope after the fact
        // doesn't do anything
        scope: this.plugin.settings.clientScope,
        // Taken from oauth 2.0 playfround at https://developers.google.com/oauthplayground/
        // See https://stackoverflow.com/questions/11475101/when-is-access-type-online-appropriate-oauth2-google-api
        // Setting to offline is necessary so a refresh_token is 
        // provided
        access_type: "offline",
        // Set to "consent" to force a consent prompt to the user and
        // return a refresh token, otherwise if the app already has an
        // unexpired token, it will be given an access token without
        // refresh token. This is the equivalent to the deprecated
        // "approval_prompt" some examples use.
        // See https://stackoverflow.com/questions/10827920/not-receiving-google-oauth-refresh-token
        // See https://developers.google.com/identity/protocols/oauth2/web-server#request-parameter-prompt
        // See https://developers.google.com/identity/openid-connect/openid-connect#re-consent
        //
        // Refresh tokens are said to last 6 months but test ones only 7
        // days. There's also a limit on per account per client id tokens
        // See https://developers.google.com/identity/protocols/oauth2#expiration
        // XXX Have a slider to force consent dialog?
        // XXX Force only if there's no refresh token? or force it
        //     unconditionally since when this is run the token has been
        //     lost anyway and only if the client has cookies won't have
        //     to consent?
        prompt: "consent"
      };
    }
    return authParams;
  }
  updateAuthLink(authLink) {
    const authParams = this.buildAuthParams();
    const authUrl = "https://accounts.google.com/o/oauth2/v2/auth?" + new URLSearchParams(authParams);
    logInfo("updateAuthLink", authUrl);
    authLink.href = authUrl;
  }
  setGoogleCloudConfigurationVisible(settings, visible) {
    for (let apiSetting of settings) {
      if (visible) {
        apiSetting.settingEl.show();
      } else {
        apiSetting.settingEl.hide();
      }
    }
  }
  onOpen() {
    const { contentEl } = this;
    this.ok = false;
    this.titleEl.setText("Google Drive login for vault ");
    this.titleEl.createEl("i", { text: this.plugin.app.vault.getName() });
    new import_obsidian.Setting(contentEl).setName("Display Google Cloud API configuration (advanced)").setDesc("If you have a Google Cloud account, you can enter your own Google Cloud API configuration. Otherwise, the plugin will use its default configuration which requires reauthorization every hour.").addToggle(
      (toggle) => toggle.setValue(this.showGoogleCloudConfiguration).onChange(async (value) => {
        logInfo("Show Google Cloud Configuration: " + value);
        this.showGoogleCloudConfiguration = value;
        this.setGoogleCloudConfigurationVisible(apiConfigSettings, this.showGoogleCloudConfiguration);
      })
    );
    let apiConfigSettings = Array();
    apiConfigSettings.push(new import_obsidian.Setting(contentEl).setName("Google API Client Id").setDesc("Enter your Google API Client Id. Leave blank to use the default one.").addText(
      (text) => text.setPlaceholder("Use default Client Id").setValue(this.plugin.settings.clientId).onChange(
        async (value) => {
          logInfo("clientId: " + value);
          this.plugin.settings.clientId = value || DEFAULT_SETTINGS.clientId;
          await this.plugin.saveSettings();
          this.updateAuthLink(authLink);
        }
      )
    ));
    apiConfigSettings.push(
      new import_obsidian.Setting(contentEl).setName("Google API Client Secret").setDesc("Enter your Google API Client Secret. Leave blank to not use a client secret, but will cause hourly re-authorization prompts.").addText((text) => {
        text.setPlaceholder("Don't use Client Secret").setValue(this.plugin.settings.clientSecret).onChange(async (value) => {
          logInfo("clientSecret: " + value);
          this.plugin.settings.clientSecret = value || DEFAULT_SETTINGS.clientSecret;
          await this.plugin.saveSettings();
          this.updateAuthLink(authLink);
        }).inputEl.type = "password";
      }).addButton(
        (button) => button.setIcon("eye").onClick(() => {
          const inputEl = button.buttonEl.previousElementSibling;
          const isPassword = inputEl.type == "text";
          inputEl.type = isPassword ? "password" : "text";
          button.setIcon(isPassword ? "eye" : "eye-off");
        })
      )
    );
    apiConfigSettings.push(
      new import_obsidian.Setting(contentEl).setName("Google API scope").setDesc("Enter the Google API scope to use. Leave blank to use the default scope which will restrict to Google Drive folders created with this app.").addText((text) => {
        text.setPlaceholder("Use default scope").setValue(this.plugin.settings.clientScope).onChange(async (value) => {
          logInfo("clientScope: " + value);
          this.plugin.settings.clientScope = value || DEFAULT_SETTINGS.clientScope;
          await this.plugin.saveSettings();
          this.updateAuthLink(authLink);
        });
      })
    );
    apiConfigSettings.push(
      new import_obsidian.Setting(contentEl).setName("Google API redirect URI").setDesc("Enter the Google API redirect URI to use. Leave blank to use the default URI which will require pasting the error URL from the browser back to the Obsidian app.").addText((text) => {
        text.setPlaceholder("Use default URI").setValue(this.plugin.settings.redirectUri).onChange(async (value) => {
          logInfo("clientScope: " + value);
          this.plugin.settings.redirectUri = value || DEFAULT_SETTINGS.redirectUri;
          await this.plugin.saveSettings();
          this.updateAuthLink(authLink);
        });
      })
    );
    this.setGoogleCloudConfigurationVisible(apiConfigSettings, this.showGoogleCloudConfiguration);
    const authLink = contentEl.createEl("a", { text: "1. Click to log in to Google Drive" });
    this.updateAuthLink(authLink);
    new import_obsidian.Setting(contentEl).setName("2. Paste Error URL").setDesc("Paste here the error URL you get after clicking on the link above").addText((text) => text.setPlaceholder("Paste here URL from google drive error page").setValue("").onChange(async (value) => {
      logInfo("errorUrl: " + value);
      const errorUrl = new URL(value);
      if (this.plugin.settings.clientSecret == "") {
        const authResult = new URLSearchParams(errorUrl.hash.substring(1));
        logInfo("accessToken", authResult.get("access_token"));
        this.plugin.settings.accessToken = authResult.get("access_token") || "";
        this.plugin.settings.accessExpires = (0, import_obsidian.moment)().add(authResult.get("expires_in"), "second").format();
      } else {
        const tokenParams = new URLSearchParams({
          code: errorUrl.searchParams.get("code"),
          redirect_uri: this.plugin.settings.redirectUri,
          client_id: this.plugin.settings.clientId,
          client_secret: this.plugin.settings.clientSecret,
          scope: this.plugin.settings.clientScope,
          grant_type: "authorization_code"
        });
        let resp = await fetch("https://oauth2.googleapis.com/token", {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          body: tokenParams
        });
        if (resp.status === 200) {
          let jsonResp = await resp.json();
          logInfo(jsonResp);
          this.plugin.settings.accessToken = jsonResp.access_token;
          this.plugin.settings.refreshToken = jsonResp.refresh_token;
          this.plugin.settings.accessExpires = (0, import_obsidian.moment)().add(jsonResp.expires_in, "second").format();
        } else {
          logError("exchange code failed", resp.status, resp.statusText);
          if (resp.headers.get("content-type") == "application/json; charset=UTF-8") {
            logWarn("fetchApi error json", await resp.json());
          }
        }
      }
      await this.plugin.saveSettings();
    }));
    const control = contentEl.createDiv("setting-item-control");
    control.style.justifyContent = "flex-start";
    if (this.showOkCancel) {
      new import_obsidian.ButtonComponent(control).setButtonText("Ok").setCta().onClick(() => {
        logInfo("LoginModal Ok");
        this.ok = true;
        this.close();
      });
      new import_obsidian.ButtonComponent(control).setButtonText("Cancel").onClick(() => {
        logInfo("LoginModal Cancel");
        this.close();
      });
    }
  }
  onClose() {
    logInfo("LoginModal.onClose", this.ok);
    const { contentEl } = this;
    contentEl.empty();
    this.resolve(this.ok);
  }
};
var GoogleDriveSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  emptyDropdown(dropdown) {
    while (dropdown.selectEl.length > 0) {
      dropdown.selectEl.remove(0);
    }
  }
  populateFoldersDropdown(dropdown, parentId) {
    logInfo("populateFoldersDropdown", dropdown, parentId);
    this.emptyDropdown(dropdown);
    dropdown.addOption("<loading>", "<loading>");
    dropdown.setDisabled(true);
    let folders = {};
    if (parentId == "root" && this.plugin.settings.browseOrphans) {
      this.fetchFolders(folders, null).then(() => {
        this.fetchFolders(folders, parentId).then(() => {
          this.emptyDropdown(dropdown);
          dropdown.addOption(".", ".");
          dropdown.addOption("<new>", "<new>");
          dropdown.addOptions(folders);
          dropdown.setDisabled(false);
        });
      });
    } else {
      this.fetchFolders(folders, parentId).then(() => {
        this.emptyDropdown(dropdown);
        dropdown.addOption(".", ".");
        dropdown.addOption("<new>", "<new>");
        if (parentId != "root") {
          dropdown.addOption("..", "..");
        }
        dropdown.addOptions(folders);
        dropdown.setDisabled(false);
      });
    }
  }
  async fetchFolders(folders, parentId, pageToken = "") {
    logInfo("fetchFolders", folders, parentId, pageToken);
    while (pageToken !== void 0) {
      let q = "(mimeType='application/vnd.google-apps.folder') and (not trashed) and ('me' in owners)";
      if (parentId != null) {
        q += " and ('" + parentId + "' in parents)";
      }
      const params = {
        q,
        // Fields can be files(*) to get all fields in the metadata
        fields: "nextPageToken, files(id, name, mimeType" + (parentId == null ? ", parents" : "") + ")",
        pageToken,
        orderBy: "folder,name"
      };
      let resp = await this.plugin.fetchJson("drive/v3/files", params);
      logInfo(resp);
      resp.files.forEach((f) => {
        let name = f.name;
        if (f.mimeType == "application/vnd.google-apps.folder") {
          name = "[" + name + "]";
        }
        if (parentId != null || f.parents === void 0) {
          folders[f.id] = name;
        }
      });
      pageToken = resp.nextPageToken;
    }
  }
  updateDriveSetting(driveSetting, path) {
    const fragment = createFragment((fragment2) => {
      fragment2.createSpan({ text: "Google Drive folder for this vault: " });
      fragment2.createDiv({ text: path }, (div) => {
        div.style.color = "var(--text-accent)";
      });
    });
    driveSetting.setDesc(fragment);
  }
  updateBrowseOrphansSetting(browseOrphansSetting) {
    logInfo("updateBroOrphansSetting", this.plugin.settings.clientScope);
    if (this.plugin.settings.clientScope == "https://www.googleapis.com/auth/drive.file") {
      browseOrphansSetting.settingEl.hide();
    } else {
      browseOrphansSetting.settingEl.show();
    }
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("small", { text: "Created by " }).appendChild(createEl("a", { text: "Antonio Tejada", href: "https://github.com/antoniotejada/" }));
    containerEl.createEl("h3", { text: "Account" });
    new import_obsidian.Setting(containerEl).setName("Google Drive login").setDesc("Configure Google Drive login credentials").addButton(
      (button) => button.setButtonText("Configure").setCta().onClick(async () => {
        await new Promise((resolve, reject) => {
          new LoginModal(this.plugin, false, resolve, reject).open();
        });
        const folderId = this.plugin.settings.folderId;
        this.populateFoldersDropdown(folders, folderId);
        this.updateBrowseOrphansSetting(browseOrphansSetting);
      })
    );
    containerEl.createEl("h3", { text: "Synchronization" });
    const browseOrphansSetting = new import_obsidian.Setting(containerEl).setName("Include orphan root folders").setDesc(`Allow browsing Google Drive orphan root folders (eg "Computers") in the Google Drive folder dropdown. If disabled, folders with an orphan root won't be available as Google Drive folder to sync to, but filling the Google Drive dropdown when browsing the root level will be faster.`).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.browseOrphans).onChange(async (value) => {
        logInfo("Browse orphans: " + value);
        this.plugin.settings.browseOrphans = value;
        await this.plugin.saveSettings();
        const folderId = this.plugin.settings.folderId;
        if (folderId == "root") {
          this.populateFoldersDropdown(folders, folderId);
        }
      })
    );
    this.updateBrowseOrphansSetting(browseOrphansSetting);
    const driveSetting = new import_obsidian.Setting(containerEl).setName("Google Drive folder").setDesc("Google Drive folder for this vault").addDropdown(
      (dropdown) => dropdown.onChange(async (value) => {
        logInfo("Google Drive folder: " + value);
        if (value == ".") {
        } else if (value == "<new>") {
          new TextInputModal(this.app, "Create Google Drive folder", "Enter folder name", async (result) => {
            logInfo("Accepted TextInputModal", result);
            const resp = await this.plugin.fetchCreateFolder(this.plugin.settings.folderId, result);
            const folderId = resp.id;
            this.parentIds.push(this.plugin.settings.folderId);
            this.plugin.settings.folderId = folderId;
            this.populateFoldersDropdown(folders, folderId);
            this.plugin.fetchFolderPath(folderId).then((path) => {
              this.updateDriveSetting(driveSetting, path);
            });
            folders.selectEl.value = ".";
            await this.plugin.saveSettings();
          }).open();
        } else {
          let folderId;
          if (value == "..") {
            folderId = this.parentIds.pop();
          } else {
            folderId = value;
            this.parentIds.push(this.plugin.settings.folderId);
          }
          this.plugin.settings.parentIds = JSON.stringify({ ids: this.parentIds });
          this.plugin.settings.folderId = folderId;
          this.populateFoldersDropdown(folders, folderId);
          this.plugin.fetchFolderPath(folderId).then((path) => {
            this.updateDriveSetting(driveSetting, path);
          });
        }
        await this.plugin.saveSettings();
      })
    );
    let folders = driveSetting.components[0];
    this.parentIds = new Array();
    if (this.plugin.settings.parentIds != "") {
      this.parentIds = JSON.parse(this.plugin.settings.parentIds).ids;
    }
    if (this.plugin.settings.accessToken != "") {
      const folderId = this.plugin.settings.folderId;
      this.populateFoldersDropdown(folders, folderId);
      if (folderId != "") {
        this.plugin.fetchFolderPath(folderId).then((path) => {
          this.updateDriveSetting(driveSetting, path);
        });
      }
    }
    if (false) {
      new import_obsidian.Setting(containerEl).setName("Synchronization interval").setDesc("Number of seconds between synchronizations to Google Drive. Set to empty to disable.").addText(
        (text) => text.setPlaceholder("Enter seconds to enable").setValue(this.plugin.settings.syncIntervalSecs).onChange(
          async (value) => {
            logInfo("syncInterval: " + value);
            this.plugin.settings.syncIntervalSecs = value;
            await this.plugin.saveSettings();
          }
        )
      );
    }
    new import_obsidian.Setting(containerEl).setName("Synchronization mode").setDesc("Only upload files, only download files, or both").addDropdown(
      (dropdown) => dropdown.addOption("both", "Upload and download files").addOption("upload", "Upload files only").addOption("download", "Download files only").setValue(this.plugin.settings.syncMode).onChange(
        async (value) => {
          logInfo("Sync mode: " + value);
          this.plugin.settings.syncMode = value;
          await this.plugin.saveSettings();
        }
      )
    );
    if (false) {
      new import_obsidian.Setting(containerEl).setName("Compress files").setDesc("Store files compressed in Google Drive").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.compressFiles).onChange(async (value) => {
          logInfo("Compress files: " + value);
          this.plugin.settings.compressFiles = value;
          await this.plugin.saveSettings();
        })
      );
    }
    if (false) {
      containerEl.createEl("h3", { text: "File encryption" });
      new import_obsidian.Setting(containerEl).setName("Password").setDesc("Store files encrypted in Google Drive using this password, leave blank for no encryption.").addText((text) => {
        text.setPlaceholder("Enter password to enable").setValue(this.plugin.settings.encryptionPassword).onChange(async (value) => {
          logInfo("password: " + value);
          this.plugin.settings.encryptionPassword = value;
          await this.plugin.saveSettings();
        }).inputEl.type = "password";
        text.inputEl.style.flexGrow = "1";
      }).addButton((button) => {
        button.setIcon("eye").onClick(() => {
          const inputEl = button.buttonEl.previousElementSibling;
          const isPassword = inputEl.type == "text";
          inputEl.type = isPassword ? "password" : "text";
          button.setIcon(isPassword ? "eye" : "eye-off");
        }).buttonEl.style.flexGrow = "0";
      });
      new import_obsidian.Setting(containerEl).setName("Encrypt filenames").setDesc("Encrypt the filenames as well as the file contents.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.encryptFilenames).onChange(async (value) => {
          logInfo("Encrypt filenames: " + value);
          this.plugin.settings.encryptFilenames = value;
          await this.plugin.saveSettings();
        })
      );
    }
    containerEl.createEl("h3", { text: "Debugging" });
    new import_obsidian.Setting(containerEl).setName("Debug level").setDesc("Messages to show in the javascript console.").addDropdown((dropdown) => dropdown.addOption("error", "Errors").addOption("warn", "Warnings").addOption("info", "Information").addOption("debug", "Verbose").setValue(this.plugin.settings.debugLevel).onChange(async (value) => {
      logInfo("Debug level: " + value);
      this.plugin.settings.debugLevel = value;
      await this.plugin.saveSettings();
    }));
  }
};
